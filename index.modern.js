import{useRef as e,useState as r,useCallback as t,useEffect as o}from"react";var n;!function(e){e.AbortError="media_aborted",e.NotAllowedError="permission_denied",e.NotFoundError="no_specified_media_found",e.NotReadableError="media_in_use",e.OverconstrainedError="invalid_media_constraints",e.TypeError="no_constraints",e.NONE="",e.NO_RECORDER="recorder_error"}(n||(n={}));class i{constructor(){this.url=null,this.blob=new Blob,this.mediaChunks=[]}setBlobProperties(e){this.blobProperties=e}storeChunk(e){this.mediaChunks.push(e)}stop(){let e=new Blob(this.mediaChunks,this.blobProperties),r=URL.createObjectURL(e);this.blob=e,this.url=r}reset(){this.mediaChunks=[]}getUrl(){return this.url}getBlob(){return this.blob}}function s({audio:s=!0,video:a=!1,onStop:c=(()=>null),screen:d=!1,mediaRecorderOptions:u=null,videoStorage:l=new i}){const p=e(null);e([]);const h=e(null),[b,m]=r("idle"),[g,w]=r(!1),[v,R]=r(null),[E,f]=r("NONE"),y=t(async()=>{m("acquiring_media");const e={audio:"boolean"==typeof s?!!s:s,video:"boolean"==typeof a?!!a:a};try{if(d){const e=await window.navigator.mediaDevices.getDisplayMedia({video:a||!0});s&&(await window.navigator.mediaDevices.getUserMedia({audio:s})).getAudioTracks().forEach(r=>e.addTrack(r)),h.current=e}else{const r=await window.navigator.mediaDevices.getUserMedia(e);h.current=r}m("idle")}catch(e){f(e.name),m("idle")}},[s,a,d]);o(()=>{if(!window.MediaRecorder)throw new Error("Unsupported Browser");if(d&&!window.navigator.mediaDevices.getDisplayMedia)throw new Error("This browser doesn't support screen capturing");const e=e=>{const r=navigator.mediaDevices.getSupportedConstraints(),t=Object.keys(e).filter(e=>!r[e]);t.length>0&&console.error(`The constraints ${t.join(",")} doesn't support on this browser. Please check your ReactMediaRecorder component.`)};"object"==typeof s&&e(s),"object"==typeof a&&e(a),u&&u.mimeType&&(MediaRecorder.isTypeSupported(u.mimeType)||console.error("The specified MIME type you supplied for MediaRecorder doesn't support this browser")),h.current||y()},[s,d,a,y,u]);const k=({data:e})=>{l.storeChunk(e)},M=()=>{l.stop();const e=l.getUrl();m("stopped"),R(e),c(e,l.getBlob())},_=e=>{w(e),h.current&&h.current.getAudioTracks().forEach(r=>r.enabled=!e)};return{error:n[E],muteAudio:()=>_(!0),unMuteAudio:()=>_(!1),startRecording:async()=>{f("NONE"),h.current||await y(),h.current&&(h.current.getTracks().some(e=>"ended"===e.readyState)&&await y(),p.current=new MediaRecorder(h.current),p.current.ondataavailable=k,p.current.onstop=M,p.current.onerror=()=>{f("NO_RECORDER"),m("idle")},p.current.start(),m("recording"))},pauseRecording:()=>{p.current&&"recording"===p.current.state&&p.current.pause()},resumeRecording:()=>{p.current&&"paused"===p.current.state&&p.current.resume()},stopRecording:()=>{p.current&&"inactive"!==p.current.state&&(m("stopping"),p.current.stop(),h.current&&h.current.getTracks().forEach(e=>e.stop()),l.reset())},mediaBlobUrl:v,status:b,isAudioMuted:g,previewStream:h.current?new MediaStream(h.current.getVideoTracks()):null,clearBlobUrl:()=>R(null)}}const a=e=>e.render(s(e));export{i as ObjectUrlStorage,a as ReactMediaRecorder,n as RecorderErrors,s as useReactMediaRecorder};
//# sourceMappingURL=index.modern.js.map
