{"version":3,"file":"index.js","sources":["src/index.ts"],"sourcesContent":["import { ReactElement, useCallback, useEffect, useRef, useState } from \"react\";\n\nexport interface IVideoStorage {\n  /** Sets blob properties. This will be called only before the first call of storeChunk() after construction or reset(). */\n  setBlobProperties(blobProperties: BlobPropertyBag): void;\n\n  /** Handle recorded video chunk. */\n  storeChunk(chunk: Blob): void;\n\n  /** Informs this storage that the last chunk has been provided. */\n  stop(): void;\n\n  /** Resets this storage so that a new video can be recorded. */\n  reset(): void;\n\n  /** Gets the URL where the video is stored. */\n  getUrl(): string | null;\n\n  /** If this storage stores all chunks in a merged Blob, returns it; otherwise returns undefined.*/\n  getBlob(): Blob | undefined;\n}\n\nexport type ReactMediaRecorderRenderProps = {\n  error: string;\n  muteAudio: () => void;\n  unMuteAudio: () => void;\n  startRecording: () => void;\n  pauseRecording: () => void;\n  resumeRecording: () => void;\n  stopRecording: () => void;\n  mediaBlobUrl: null | string;\n  status: StatusMessages;\n  isAudioMuted: boolean;\n  previewStream: MediaStream | null;\n  clearBlobUrl: () => void;\n};\n\nexport type ReactMediaRecorderHookProps = {\n  audio?: boolean | MediaTrackConstraints;\n  video?: boolean | MediaTrackConstraints;\n  screen?: boolean;\n  onStop?: (blobUrl: string | null, blob: Blob | undefined) => void;\n  blobPropertyBag?: BlobPropertyBag;\n  mediaRecorderOptions?: MediaRecorderOptions | null;\n  videoStorage?: IVideoStorage;\n};\nexport type ReactMediaRecorderProps = ReactMediaRecorderHookProps & {\n  render: (props: ReactMediaRecorderRenderProps) => ReactElement;\n};\n\nexport type StatusMessages =\n  | \"media_aborted\"\n  | \"permission_denied\"\n  | \"no_specified_media_found\"\n  | \"media_in_use\"\n  | \"invalid_media_constraints\"\n  | \"no_constraints\"\n  | \"recorder_error\"\n  | \"idle\"\n  | \"acquiring_media\"\n  | \"delayed_start\"\n  | \"recording\"\n  | \"stopping\"\n  | \"stopped\";\n\nexport enum RecorderErrors {\n  AbortError = \"media_aborted\",\n  NotAllowedError = \"permission_denied\",\n  NotFoundError = \"no_specified_media_found\",\n  NotReadableError = \"media_in_use\",\n  OverconstrainedError = \"invalid_media_constraints\",\n  TypeError = \"no_constraints\",\n  NONE = \"\",\n  NO_RECORDER = \"recorder_error\",\n}\n\nclass UploadStorage implements IVideoStorage {\n  blobProperties: any;\n  url: string | null = null;\n  blob: Blob = new Blob();\n  mediaChunks: Blob[] = [];\n\n  setBlobProperties(blobProperties: BlobPropertyBag): void {\n    this.blobProperties = blobProperties;\n  }\n  storeChunk(chunk: Blob) {}\n  stop() {}\n  reset() {}\n  getUrl(): string | null {\n    return this.url;\n  }\n  getBlob(): Blob | undefined {\n    return this.blob;\n  }\n}\n\nexport class ObjectUrlStorage implements IVideoStorage {\n  blobProperties: any;\n  url: string | null = null;\n  blob: Blob = new Blob();\n  mediaChunks: Blob[] = [];\n\n  setBlobProperties(blobProperties: BlobPropertyBag): void {\n    this.blobProperties = blobProperties;\n  }\n  storeChunk(chunk: Blob) {\n    this.mediaChunks.push(chunk);\n  }\n  stop() {\n    let blob = new Blob(this.mediaChunks, this.blobProperties);\n    let url = URL.createObjectURL(blob);\n    this.blob = blob;\n    this.url = url;\n  }\n  reset() {\n    this.mediaChunks = [];\n  }\n  getUrl(): string | null {\n    return this.url;\n  }\n  getBlob(): Blob | undefined {\n    return this.blob;\n  }\n}\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = null,\n  videoStorage = new ObjectUrlStorage(),\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | null>(null);\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\n\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video,\n    };\n    try {\n      if (screen) {\n        //@ts-ignore\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true,\n        })) as MediaStream;\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio,\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus(\"idle\");\n    } catch (error) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      //@ts-ignore\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n        navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n          `The constraints ${unSupportedConstraints.join(\n            \",\"\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    if (!mediaStream.current) {\n      getMediaStream();\n    }\n  }, [audio, screen, video, getMediaStream, mediaRecorderOptions]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === \"ended\");\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    let blobPropertiesState = false;\n    if ((blobPropertiesState = false)) {\n      const blobProperties: BlobPropertyBag = Object.assign(\n        { type: data.type },\n        blobPropertyBag ||\n          (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\n      );\n\n      videoStorage.setBlobProperties(blobProperties);\n      blobPropertiesState = true;\n    }\n\n    videoStorage.storeChunk(data);\n  };\n\n  const onRecordingStop = () => {\n    videoStorage.stop();\n    const url = videoStorage.getUrl();\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, videoStorage.getBlob());\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        mediaStream.current &&\n          mediaStream.current.getTracks().forEach((track) => track.stop());\n        videoStorage.reset();\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    clearBlobUrl: () => setMediaBlobUrl(null),\n  };\n}\n\nexport const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props));\n"],"names":["RecorderErrors","ObjectUrlStorage","this","Blob","setBlobProperties","blobProperties","storeChunk","chunk","mediaChunks","push","stop","blob","url","URL","createObjectURL","reset","getUrl","getBlob","useReactMediaRecorder","audio","video","onStop","screen","mediaRecorderOptions","videoStorage","mediaRecorder","useRef","mediaStream","useState","status","setStatus","isAudioMuted","setIsAudioMuted","mediaBlobUrl","setMediaBlobUrl","error","setError","getMediaStream","useCallback","requiredMedia","window","navigator","mediaDevices","getDisplayMedia","stream","current","getUserMedia","audioStream","getAudioTracks","forEach","audioTrack","addTrack","name","useEffect","MediaRecorder","Error","checkConstraints","mediaType","supportedMediaConstraints","getSupportedConstraints","unSupportedConstraints","Object","keys","filter","constraint","length","console","join","mimeType","isTypeSupported","onRecordingActive","data","onRecordingStop","muteAudio","mute","enabled","unMuteAudio","startRecording","ondataavailable","onstop","onerror","start","isStreamEnded","getTracks","some","track","readyState","pauseRecording","state","pause","resumeRecording","resume","stopRecording","previewStream","MediaStream","getVideoTracks","clearBlobUrl","props","render"],"mappings":"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"}