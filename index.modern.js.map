{"version":3,"file":"index.modern.js","sources":["src/index.ts"],"sourcesContent":["import { ReactElement, useCallback, useEffect, useRef, useState } from \"react\";\n\nexport interface IVideoStorage {\n  /** Sets blob properties. This will be called only before the first call of storeChunk() after construction or reset(). */\n  setBlobProperties(blobProperties: BlobPropertyBag): void;\n\n  /** Handle recorded video chunk. */\n  storeChunk(chunk: Blob): void;\n\n  /** Informs this storage that the last chunk has been provided. */\n  stop(): void;\n\n  /** Resets this storage so that a new video can be recorded. */\n  reset(): void;\n\n  /** Gets the URL where the video is stored. */\n  getUrl(): string | null;\n\n  /** If this storage stores all chunks in a merged Blob, returns it; otherwise returns undefined.*/\n  getBlob(): Blob | undefined;\n}\n\nexport type ReactMediaRecorderRenderProps = {\n  error: string;\n  muteAudio: () => void;\n  unMuteAudio: () => void;\n  startRecording: () => void;\n  pauseRecording: () => void;\n  resumeRecording: () => void;\n  stopRecording: () => void;\n  mediaBlobUrl: null | string;\n  status: StatusMessages;\n  isAudioMuted: boolean;\n  previewStream: MediaStream | null;\n  clearBlobUrl: () => void;\n};\n\nexport type ReactMediaRecorderHookProps = {\n  audio?: boolean | MediaTrackConstraints;\n  video?: boolean | MediaTrackConstraints;\n  screen?: boolean;\n  onStop?: (blobUrl: string | null, blob: Blob | undefined) => void;\n  blobPropertyBag?: BlobPropertyBag;\n  mediaRecorderOptions?: MediaRecorderOptions | null;\n  videoStorage?: IVideoStorage;\n};\nexport type ReactMediaRecorderProps = ReactMediaRecorderHookProps & {\n  render: (props: ReactMediaRecorderRenderProps) => ReactElement;\n};\n\nexport type StatusMessages =\n  | \"media_aborted\"\n  | \"permission_denied\"\n  | \"no_specified_media_found\"\n  | \"media_in_use\"\n  | \"invalid_media_constraints\"\n  | \"no_constraints\"\n  | \"recorder_error\"\n  | \"idle\"\n  | \"acquiring_media\"\n  | \"delayed_start\"\n  | \"recording\"\n  | \"stopping\"\n  | \"stopped\";\n\nexport enum RecorderErrors {\n  AbortError = \"media_aborted\",\n  NotAllowedError = \"permission_denied\",\n  NotFoundError = \"no_specified_media_found\",\n  NotReadableError = \"media_in_use\",\n  OverconstrainedError = \"invalid_media_constraints\",\n  TypeError = \"no_constraints\",\n  NONE = \"\",\n  NO_RECORDER = \"recorder_error\",\n}\n\nclass UploadStorage implements IVideoStorage {\n  blobProperties: any;\n  url: string | null = null;\n  blob: Blob = new Blob();\n  mediaChunks: Blob[] = [];\n\n  setBlobProperties(blobProperties: BlobPropertyBag): void {\n    this.blobProperties = blobProperties;\n  }\n  storeChunk(chunk: Blob) {}\n  stop() {}\n  reset() {}\n  getUrl(): string | null {\n    return this.url;\n  }\n  getBlob(): Blob | undefined {\n    return this.blob;\n  }\n}\n\nexport class ObjectUrlStorage implements IVideoStorage {\n  blobProperties: any;\n  url: string | null = null;\n  blob: Blob = new Blob();\n  mediaChunks: Blob[] = [];\n\n  setBlobProperties(blobProperties: BlobPropertyBag): void {\n    this.blobProperties = blobProperties;\n  }\n  storeChunk(chunk: Blob) {\n    this.mediaChunks.push(chunk);\n  }\n  stop() {\n    let blob = new Blob(this.mediaChunks, this.blobProperties);\n    let url = URL.createObjectURL(blob);\n    this.blob = blob;\n    this.url = url;\n  }\n  reset() {\n    this.mediaChunks = [];\n  }\n  getUrl(): string | null {\n    return this.url;\n  }\n  getBlob(): Blob | undefined {\n    return this.blob;\n  }\n}\n\nexport function useReactMediaRecorder({\n  audio = true,\n  video = false,\n  onStop = () => null,\n  blobPropertyBag,\n  screen = false,\n  mediaRecorderOptions = null,\n  videoStorage = new ObjectUrlStorage(),\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\n  const mediaChunks = useRef<Blob[]>([]);\n  const mediaStream = useRef<MediaStream | null>(null);\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\n  const [isAudioMuted, setIsAudioMuted] = useState<boolean>(false);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | null>(null);\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\n\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia: MediaStreamConstraints = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video,\n    };\n    try {\n      if (screen) {\n        //@ts-ignore\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true,\n        })) as MediaStream;\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio,\n          });\n\n          audioStream\n            .getAudioTracks()\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\n        }\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(\n          requiredMedia\n        );\n        mediaStream.current = stream;\n      }\n      setStatus(\"idle\");\n    } catch (error) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      //@ts-ignore\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\n      const supportedMediaConstraints =\n        navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(\n        (constraint) =>\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\n      );\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\n          `The constraints ${unSupportedConstraints.join(\n            \",\"\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\n        );\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\n        );\n      }\n    }\n\n    if (!mediaStream.current) {\n      getMediaStream();\n    }\n  }, [audio, screen, video, getMediaStream, mediaRecorderOptions]);\n\n  // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current\n        .getTracks()\n        .some((track) => track.readyState === \"ended\");\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = ({ data }: BlobEvent) => {\n    let blobPropertiesState = false;\n    if ((blobPropertiesState = false)) {\n      const blobProperties: BlobPropertyBag = Object.assign(\n        { type: data.type },\n        blobPropertyBag ||\n          (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\n      );\n\n      videoStorage.setBlobProperties(blobProperties);\n      blobPropertiesState = true;\n    }\n\n    videoStorage.storeChunk(data);\n  };\n\n  const onRecordingStop = () => {\n    videoStorage.stop();\n    const url = videoStorage.getUrl();\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, videoStorage.getBlob());\n  };\n\n  const muteAudio = (mute: boolean) => {\n    setIsAudioMuted(mute);\n    if (mediaStream.current) {\n      mediaStream.current\n        .getAudioTracks()\n        .forEach((audioTrack) => (audioTrack.enabled = !mute));\n    }\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      mediaRecorder.current.pause();\n    }\n  };\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        mediaStream.current &&\n          mediaStream.current.getTracks().forEach((track) => track.stop());\n        videoStorage.reset();\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: () => muteAudio(true),\n    unMuteAudio: () => muteAudio(false),\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    isAudioMuted,\n    previewStream: mediaStream.current\n      ? new MediaStream(mediaStream.current.getVideoTracks())\n      : null,\n    clearBlobUrl: () => setMediaBlobUrl(null),\n  };\n}\n\nexport const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\n  props.render(useReactMediaRecorder(props));\n"],"names":["RecorderErrors","ObjectUrlStorage","constructor","this","Blob","setBlobProperties","blobProperties","storeChunk","chunk","mediaChunks","push","stop","blob","url","URL","createObjectURL","reset","getUrl","getBlob","useReactMediaRecorder","audio","video","onStop","screen","mediaRecorderOptions","videoStorage","mediaRecorder","useRef","mediaStream","status","setStatus","useState","isAudioMuted","setIsAudioMuted","mediaBlobUrl","setMediaBlobUrl","error","setError","getMediaStream","useCallback","async","requiredMedia","stream","window","navigator","mediaDevices","getDisplayMedia","getUserMedia","getAudioTracks","forEach","audioTrack","addTrack","current","name","useEffect","MediaRecorder","Error","checkConstraints","mediaType","supportedMediaConstraints","getSupportedConstraints","unSupportedConstraints","Object","keys","filter","constraint","length","console","join","mimeType","isTypeSupported","onRecordingActive","data","onRecordingStop","muteAudio","mute","enabled","unMuteAudio","startRecording","getTracks","some","track","readyState","ondataavailable","onstop","onerror","start","pauseRecording","state","pause","resumeRecording","resume","stopRecording","previewStream","MediaStream","getVideoTracks","clearBlobUrl","ReactMediaRecorder","props","render"],"mappings":"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"}